---
title: 精通Python设计模式
date: 2019-06-12 18:54:44 +0800
categories: 计算
tags: [Python, 面向对象, 设计模式]
gist: 
excerpt_separator: .. 摘要注释

---
.. container:: summary

    **设计模式**\ 是在已有的方案之上发现更好的方案，而不是全新发明。

.. 摘要注释

软件开发不是一蹴而就的事，而是一个不断改善的过程。随着需求的变化，在——读代码、写代码——这个迭代过程中，我们面临着权衡取舍，为控制软件的复杂度而努力着。

设计模式是应对软件复杂度的有效方法，是前人对设计原则的解读、对优秀代码的抽象，可分为创建型、结构型、以及行为型。设计模式好用，但不可滥用，需要结合相应的上下文来使用。

本书的作者用简单、明了的文字讲解了16种设计模式，使得整本书具有很高的可读性，有助于读者对模式的识别。

文摘
----

设计模式并不是万能的，仅当代码确实存在坏味道、难以扩展维护时，才有使用的必要。

**工厂模式**\ 通常有两种形式：一种是工厂方法（Factory Method），它是一个方法/函数，对不同的输入参数返回不同的对象；第二种是抽象工厂，它是一组用于创建一系列相关事物对象的工厂方法。

在\ **建造者模式**\ 中，有两个参与者：建造者（builder）和指挥者（director）。建造者负责创建复杂对象的各个组成部分，指挥者使用一个建造者实例控制建造的过程。同\ **工厂模式**\ 的主要的区别在于：工厂模式以单个步骤创建对象，而建造者模式以多个步骤创建对象，并且几乎始终会使用一个指挥者。

**适配器模式**\ ，无需修改不兼容模型的源代码就能获得接口的一致性。

**装饰器模式**\ 能够以透明的方式（不会影响其他对象）动态地将功能添加到一个对象中，是实现横切关注点的绝佳方案。

**外观设计模式**\ 有助于隐藏系统的内部复杂性，并通过一个简化的接口向客户端暴露必要的部分，是在已有复杂系统之上实现的一个抽象层。

**享元模式**\ 通过为相似对象引入数据共享来最小化内存使用，提升性能。一个享元（Flyweight）就是一个包含状态独立的不可变（又称固有的）数据的共享对象，非固有的数据应由客户端代码显式地提供。

**关注点分离原则**\ （Separation of Concerns，SoC）是将一个应用切分成不同的部分，每个部分解决一个单独的关注点。\ **模型—视图—控制器模式**\ 是一种架构模式，它将应用切分成三个部分：模型、视图和控制器。模型是核心的部分，代表着应用的信息本源，包含和管理（业务）逻辑、数据、状态以及应用的规则；视图是模型的可视化表现；控制器是模型与视图之间的链接/粘附，模型与视图之间的所有通信都通过控制器进行。为了实现模型与其表现之间的解耦，每个视图通常都需要有属于它的控制器。

.. compound::

    **代理模式**\ 因使用代理对象在访问实际对象之前执行重要操作而得其名，以下是四种不同的知名代理类型：
    
    - 远程代理：实际存在于不同地址空间的对象在本地的代理者
    - 虚拟代理：用于懒初始化，将一个大计算量对象的创建延迟到真正需要的时候进行
    - 保护/防护代理：控制对敏感对象的访问
    - 智能（引用）代理：在对象被访问时执行额外的动作

**责任链模式**\ 用于让多个对象来处理单个请求时，或者用于预先不知道应该由哪个对象（来自某个对象链）来处理某个特定请求时。发送方可直接访问链中的首个节点，若首个节点不能处理请求，则转发给下一个节点，如此直到请求被某个节点处理或者整个链遍历结束，从而实现发送方与接收方（多个）之间的解耦。

**命令模式**\ 将一个操作封装成一个对象。可以在任何时候执行一个命令，而并不一定是在命令创建时；调用者与执行者解耦，调用者无需知道命令的任何实现细节；可以对命令进行分组，并按一定的顺序执行。

**观察者模式**\ 描述单个对象（发布者，又称为主持者或可观察者）与一个或多个对象（订阅者，又称为观察者）之间的发布—订阅关系，可以降低发布者与订阅者之间的耦合度，从而易于在运行时添加/删除订阅者。

**状态模式**\ 就是应用到一个特定软件工程问题的状态机，核心部分是状态和状态之间的转换，解决的是一定上下文中无限数量状态的完全封装，从而实现更好的可维护性和灵活性。

**策略模式**\ 鼓励使用多种算法来解决一个问题，其杀手级特性是能够在运行时透明地切换算法（客户端代码对变化无感知）。

**模板模式**\ 关注的是消除代码冗余，其思想是无需改变算法结构就能重新定义一个算法的某些部分。
