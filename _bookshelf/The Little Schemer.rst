---
title: The Little Schemer
date: 2019-01-09 17:08:48 +0800
categories: 计算
tags: [Lisp, Scheme, 算法]
excerpt_separator: .. 摘要注释
---

.. class:: excerpt

    如何跟上“第一代黑客”的步伐，这是个问题！

.. 摘要注释

----

如果没有认真阅读前言，那么你将觉得本书晦涩难懂，完全不知所云。为了从繁杂的代码中剥离出简明的递归片段，本书预先设置了诸多约束条件。只有明了了这些约束条件，才能跟上黑客的步伐。

不要纠结于使用哪一种\ *Scheme*\ 实现（\ `Chez Scheme <https://www.scheme.com/>`_\ 、\ `MIT/GNU Scheme <http://www.gnu.org/software/mit-scheme/>`_\ ），因为在这两种实现中，\ ``eq?``\ 可以对“数字”与“字符串”进行比较。重要的事情是：一问一答的过程中，跟紧黑客，在\ *VIM*\ 的\ *Lisp*\ 模式下编写代码。

通过高阶函数实现“柯里化”与“偏函数”后，证明了“停机问题”。在阅读“应用序Y组合子”的演算过程中，你的头脑会爆炸，但你将掌握“使用匿名函数进行递归调用”的方法：

.. include:: gists/{{ page.gist }}/413b7b178085f2973427d594f008d88d/the-little-schemer.scm
    :code: scheme
    :start-line: 2
    :end-line: 15

\ *Scheme*\ 作为\ *Lisp*\ 的一种方言，有着极其简单的语法与语义。在本书最后，作者将通过将“符号”映射到“值”，实现了一个简单的“解释器”，阐明了计算的一般本质——\ **模式识别**\ 。
    
文摘
----

Scheme 十诫
~~~~~~~~~~~
第一诫
    当对一个原子列表 ``lat`` 进行递归调用时，询问两个有关 ``lat`` 的问题： ``(null? lat)`` 和 ``else`` 。

    当对一个数字 ``n`` 进行递归调用时，询问两个有关 ``n`` 的问题： ``(zero? n)`` 和 ``else`` 。

    当对一个 *S*-表达式列表 ``l`` 进行递归调用时，询问三个有关 ``l`` 的问题： ``(null? lat)`` 、 ``(atom? (car l))`` 和 ``else`` 。
第二诫
    使用 ``cons`` 来构建列表
第三诫
    构建一个列表的时候， 描述第一个典型元素，之后 ``cons`` 该元素到一般性递归（natural recursion）上。
第四诫
    在递归时总是改变至少一个参数。当对一个原子列表 ``lat`` 进行递归调用时，使用 ``(cdr lat)`` 。当对一个数字 ``n`` 进行递归调用时，使用 ``(sub1 n)`` 。当对一个 *S*-表达式 ``l`` 进行递归调用时， 只要 ``(null? l)`` 和 ``(atom? (car l))`` 都不为 ``true`` ，那么就同时使用 ``(car l)`` 和 ``(cdr l)`` 。
    
    .. compound::

        在递归时改变的参数，必须向着不断接近结束条件而改变。改变的参数必须在结束条件中得以测试：

            当使用 ``cdr`` 时，用 ``null?`` 测试是否结束；

            当使用 ``sub1`` 时，用 ``zero?`` 测试否结束。
第五诫
    在用 ``✚`` 构建一个值时，总是使用 ``0`` 作为结束代码行的值，因为加上 ``0`` 不会改变加法的值。

    在用 ``✖`` 构建一个值时，总是使用 ``1`` 作为结束代码行的值，因为乘以 ``1`` 不会改变乘法的值。

    在用 ``cons`` 构建一个值时，总是考虑把 ``()`` 作为结束代码行的值。
第六诫
    简化工作只在功能正确之后开展。
第七诫
    .. compound::

        对具有相同性质的 ``subparts`` （子部件）进行递归调用：
            
            * 列表的子列表；
            * 算术表达式的子表达式。
第八诫
    使用辅助函数来抽象表示方法。
第九诫
    用函数来抽象通用模式。
第十诫
    构建函数，一次收集多个值。

Scheme 五法
~~~~~~~~~~~
第一法—— ``car`` 之法则
    基本元件 ``car`` 仅定义为针对非空列表
第二法—— ``cdr`` 之法则
    基本元件 ``cdr`` 仅定义为针对非空列表。任意非空列表的 ``cdr`` 总是另一个列表。
第三法—— ``cons`` 之法则
    基本元件 ``cons`` 需要两个参数。第二个参数必须是个列表。结果是个列表。
第四法—— ``null?`` 之法则
    基本元件 ``null?`` 仅定义为针对列表。
第五法—— ``eq?`` 之法则
    基本元件 ``eq?`` 需要两个参数。每个参数都必须是一个非数字的原子。

.. footer::

    结合上下文（context）语境，获取你的映射。

    .. epigraph::

        “惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。”——苏轼 《前赤壁赋》

